In the brute force approach, we make use of a recursive function dfsdfs, which returns the number of vacations which can be taken startring from cur\_citycur_city as the current city and weeknoweekno as the starting week.

In every function call, we traverse over all the cities(represented by ii) and find out all the cities which are connected to the current city, cur\_citycur_city. Such a city is represented by a 1 at the corresponding flights[cur\_city][i]flights[cur_city][i] position. Now, for the current city, we can either travel to the city which is connected to it or we can stay in the same city. Let's say the city to which we change our location from the current city be represented by jj. Thus, after changing the city, we need to find the number of vacations which we can take from the new city as the current city and the incremented week as the new starting week. This count of vacations can be represented as: days[j][weekno] + dfs(flights, days, j, weekno + 1)days[j][weekno]+dfs(flights,days,j,weekno+1).

Thus, for the current city, we obtain a number of vacations by choosing different cities as the next cities. Out of all of these vacations coming from different cities, we can find out the maximum number of vacations that need to be returned for every dfsdfs function call.